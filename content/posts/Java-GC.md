---
title: Java GC
date: 2017-12-07 14:53:43
tags: ["Java"]
categories: ["Java"]
---

## 判断对象是否存活
### 引用计数法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是还不可能再被使用的。实现简单，判定效率高，但很难解决对象之间相互循环引用的问题。

### 可达性分析算法
通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）引用的对象

### Java中的引用
Java将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。

- 强引用：只要强引用还存在，垃圾收集器永远不会回收被引用的对象。
- 软引用：在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，Java中提供了SoftReference类来实现软引用。
- 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生之前。Java中提供了WeakReference类来实现弱引用。
- 虚引用，也称为幽灵引用或者幻影引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。Java中提供了PhantomReference类来实现虚引用。

### finalize方法
如果对象在进行可达性分析之后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。

任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时。

## 垃圾收集算法
### 标记-清除算法
首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片。

### 复制算法
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一快上面，然后再把已使用过的内存一次清理掉。代价是将内存缩小为了原来的一半。

现在的商业虚拟机都采用这种收集算法来回收新生代。但是并不需要按照1:1的比例划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。Hotspot虚拟机默认Eden和Survivor的大小比例是8:1。当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。

### 标记-整理算法
根据老年代的特点，标记-整理算法的标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一边移动，然后直接清理掉端边界以外的内存。

### 分代收集算法
一般把Java堆分成新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

## 垃圾收集器
### Serial收集器
单线程的收集器，并且在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。新生代收集器。复制算法。

### ParNew收集器
Serial收集器的多线程版本。新生代收集器。复制算法。

### Parallel Scavenge收集器
新生代收集器。复制算法。并行的多线程收集器。Parallel Scavenge收集器的目的则是达到一个可控制的吞吐量。提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。

### Serial Old收集器
Serial收集器的老年代版本，单线程，使用标记-整理算法。

### Parallel Old收集器
Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。

### CMS（Concurrent Mark Sweep）收集器
以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，包括以下4个步骤：

- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）
其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是进行GC Roots Tracing的过程；而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

### G1收集器
特点：

- 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势。
- 分代收集：G1可以不需要其他收集器配合就能独立管理整个GC堆。
- 空间整合：G1从整体来看是基于“标记-整理”算法实现的收集器。
- 可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

将整个Java堆划分为多个大小相等的独立区域（Region），跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。

步骤：

- 初始标记（Initial Marking）
- 并发标记（Concurrent Marking）
- 最终标记（Final Marking）
- 筛选回收（Live Data Counting and Evacuation）
